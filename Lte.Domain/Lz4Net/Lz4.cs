using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;

namespace Lte.Domain.Lz4Net
{
    public static class Lz4
    {
        public static unsafe int Compress(byte[] data, int offset, int length, ref byte[] buffer, Lz4Mode mode)
        {
            int num;
            int num2 = LZ4_compressBound(length) + 8;
            if ((buffer == null) || (buffer.Length < num2))
            {
                buffer = new byte[num2];
            }
            fixed (byte* numRef = &(data[offset]))
            {
                fixed (byte* numRef2 = &(buffer[8]))
                {
                    num = (mode == Lz4Mode.Fast) ? LZ4_compress(numRef, numRef2, length) : LZ4_compressHC(numRef, numRef2, length);
                    byte* numPtr = (byte*)&length;
                    buffer[0] = numPtr[0];
                    buffer[1] = numPtr[1];
                    buffer[2] = numPtr[2];
                    buffer[3] = numPtr[3];
                    numPtr = (byte*)&num;
                    buffer[4] = numPtr[0];
                    buffer[5] = numPtr[1];
                    buffer[6] = numPtr[2];
                    buffer[7] = numPtr[3];
                }
            }
            return (num + 8);
        }

        public static byte[] CompressBytes(byte[] data, Lz4Mode mode = 0)
        {
            return CompressBytes(data, 0, data.Length, mode);
        }

        public static byte[] CompressBytes(byte[] data, int offset, int length, Lz4Mode mode)
        {
            if (length > data.Length)
            {
                throw new ArgumentOutOfRangeException("length");
            }
            byte[] buffer = null;
            int count = Compress(data, 0, length, ref buffer, mode);
            byte[] dst = new byte[count];
            Buffer.BlockCopy(buffer, 0, dst, 0, count);
            return dst;
        }

        public static string CompressString(string text, Lz4Mode mode = 0)
        {
            byte[] bytes = Encoding.UTF8.GetBytes(text);
            return Convert.ToBase64String(CompressBytes(bytes, 0, bytes.Length, mode));
        }

        public static unsafe int Decompress(byte[] data, int offset, ref byte[] buffer)
        {
            int num;
            fixed (byte* numRef = &(data[offset]))
            {
                if (data.Length < numRef[4])
                {
                    throw new Exception("Input data is incomplete. Total data array size is lesser than header info size. Data array could be incomplete or was not generated by 'CompressBytes' or 'Compress'.");
                }
                num = *((int*)numRef);
                if ((buffer == null) || (buffer.Length < num))
                {
                    buffer = new byte[num];
                }
                fixed (byte* numRef2 = buffer)
                {
                    LZ4_uncompress(numRef + 8, numRef2, num);
                }
            }
            return num;
        }

        public static byte[] DecompressBytes(byte[] data)
        {
            byte[] buffer = null;
            Decompress(data, 0, ref buffer);
            return buffer;
        }

        public static string DecompressString(string compressedText)
        {
            byte[] bytes = DecompressBytes(Convert.FromBase64String(compressedText));
            return Encoding.UTF8.GetString(bytes);
        }

        public static unsafe int GetCompressedSize(byte[] data)
        {
            if ((data == null) || (data.Length < 8))
            {
                return 0;
            }
            fixed (byte* numRef = &(data[4]))
            {
                return *(((int*)numRef));
            }
        }

        public static unsafe int GetUncompressedSize(byte[] data)
        {
            if ((data == null) || (data.Length < 8))
            {
                return 0;
            }
            fixed (byte* numRef = data)
            {
                return *(((int*)numRef));
            }
        }

        public static unsafe int LZ4_compress(byte* source, byte* destination, int size)
        {
            if (IntPtr.Size != 4)
            {
                return LZ4_compress_x64(source, destination, size);
            }
            return LZ4_compress_x86(source, destination, size);
        }

        [DllImport(@"x64\lz4X64.dll", EntryPoint = "dll_LZ4_compress", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_compress_x64(byte* source, byte* destination, int size);

        [DllImport(@"x86\lz4X86.dll", EntryPoint = "dll_LZ4_compress", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_compress_x86(byte* source, byte* destination, int size);

        public static int LZ4_compressBound(int isize)
        {
            return ((isize + (isize / 0xff)) + 0x10);
        }

        public static unsafe int LZ4_compressHC(byte* source, byte* destination, int size)
        {
            if (IntPtr.Size != 4)
            {
                return LZ4_compressHC_x64(source, destination, size);
            }
            return LZ4_compressHC_x86(source, destination, size);
        }

        [DllImport(@"x64\lz4X64.dll", EntryPoint = "dll_LZ4_compressHC", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_compressHC_x64(byte* source, byte* destination, int size);

        [DllImport(@"x86\lz4X86.dll", EntryPoint = "dll_LZ4_compressHC", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_compressHC_x86(byte* source, byte* destination, int size);

        public static unsafe int LZ4_uncompress(byte* source, byte* destination, int originalSize)
        {
            if (IntPtr.Size != 4)
            {
                return LZ4_uncompress_x64(source, destination, originalSize);
            }
            return LZ4_uncompress_x86(source, destination, originalSize);
        }

        [DllImport(@"x64\lz4X64.dll", EntryPoint = "dll_LZ4_uncompress", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_uncompress_x64(byte* source, byte* destination, int size);

        [DllImport(@"x86\lz4X86.dll", EntryPoint = "dll_LZ4_uncompress", CallingConvention = CallingConvention.Cdecl)]
        private static extern unsafe int LZ4_uncompress_x86(byte* source, byte* destination, int size);
    }
}
